import numpy as np
from trinaryVector import Individual as TriVecIndividual

class Individual(TriVecIndividual):
	'''Class for evolutionary individuals described by a vector of 
     numbers taken from {-1,0,1} of constant length with mutation 
     operator taken from the Espinosa-Soto Wagner 2010 paper 
     (DOI: 10.1371/journal.pcbi.1000719). Additionally, a function 
     initSparse(self) is provided, which makes an empty random 
     vector and adds self.params['initDensity'] connections to it 
     at random. Constructor takes a dictionary with the 
     following parameter fields:
       length              - length of the vector
       mutProbability      - probability of mutation per each E-S W 
                             gene (number of nodes is a square root 
                             of length)
       initDensity         - number of connections in the E-S W 
                             initial network (generated by 
                             initSparse(self))

	'''
	def __init__(self, params):
		super(TriVecIndividual, self).__init__(params)
		if not np.sqrt(self.params['length']).is_integer():
			raise ValueError('Length of such vectors should be a square of an integer')
		self.numNodes = int(np.sqrt(self.params['length']))
		self.values = np.random.random_integers(-1, 1, size=self.params['length'])

	def requiredParametersTranslator(self):
		t = super(Individual, self).requiredParametersTranslator()
		t['toFloat'].add('mutProbability')
		t['toInt'].add('initDensity')
		return t

	def insert(self):
		space = len(self.values) - np.count_nonzero(self.values)
		if space < 1:
			return False
		pos = np.random.randint(space)
		for i in xrange(len(self.values)):
			if self.values[i] == 0:
				if pos == 0:
					self.values[i] = 1 if np.random.random() > 0.5 else -1
					return True
				else:
					pos -= 1
		print("Insert: One should not dwell here\n")

	def initSparse(self):
		self.values = np.zeros(self.params['length'], dtype=np.int)
		while np.count_nonzero(self.values) < self.params['initDensity']:
			self.insert()
		self.renewID()

	def countRegulators(self, node):
		adjMat = self.values.reshape(self.numNodes, self.numNodes)
		connections = adjMat[:, node]
		return np.count_nonzero(connections)

	def mutateNode(self, node):
		regulators = self.countRegulators(node)
		probDel = (4.0*regulators)/(4.0*regulators + (self.numNodes - regulators))
		if np.random.random() < probDel:
			# remove randomly selected regulator
			pos = np.random.randint(regulators)
			secondNode = 0
			while True:
				if self.values[secondNode*self.numNodes + node] != 0:
					if pos == 0:
						break
					pos -= 1
				secondNode += 1
			self.values[secondNode*self.numNodes + node] = 0
		else:
			# add randomly selected regulator
			pos = np.random.randint(self.numNodes - regulators)
			secondNode = 0
			while True:
				if self.values[secondNode*self.numNodes + node] == 0:
					if pos == 0:
						break
					pos -= 1
				secondNode += 1
			self.values[secondNode*self.numNodes + node] = -1 if np.random.random() < 0.5 else 1

	def mutate(self):
		mutated = False
		for i in xrange(self.numNodes):
			if np.random.random() < self.params['mutProbability']:
				self.mutateNode(i)
				mutated = True
		if mutated:
			self.renewID()
		return mutated
